#include "mainwindow.h"
#include "./ui_mainwindow.h"
#include <QMessageBox>
#include <QFileDialog>
#include <QProcess>
#include <QDir>
#include <QDebug>
#include <QFileSystemWatcher>
// здесь описаны графические функции для алгоритма шифрования AES


// Функция для чтения ключа
void read_key_AES(const QString& save_key, Ui::MainWindow* ui)
{
    QFile file(save_key);
    if (!file.open(QIODevice::ReadOnly)) {
        qWarning("Не удалось открыть файл для чтения!");
        return;
    }

    QByteArray data = file.readAll(); // Считываем все данные из файла
    ui->lineEdit_5->setText(QString(data)); // Выводим данные в lineEdit
    file.close();
}
void AES_error_not_argument(int yazyk_id){
    QMessageBox msgBox;  // диалоговое окно
    QString yved[10] = {"Чтобы шифровать файлы или текст, а также расшифровывать их необходимо ввести или считать ключ, также его можно сгенерировать, нажав на соответствующую кнопку. И если вы хотите шифровать и расшифровывать текст, введите его в верхнее поле ввода.", "To encrypt files or text, as well as decrypt them, you need to enter or read the key, and it can also be generated by clicking on the appropriate button. And if you want to encrypt and decrypt the text, enter it in the upper input field.", "Um Dateien oder Text zu verschlüsseln und zu entschlüsseln, müssen Sie einen Schlüssel eingeben oder auslesen, der auch durch Klicken auf die entsprechende Schaltfläche generiert werden kann. Und wenn Sie den Text verschlüsseln und entschlüsseln möchten, geben Sie ihn in das obere Eingabefeld ein.", "Pour chiffrer des fichiers ou du texte, ainsi que pour les déchiffrer, vous devez entrer ou lire la clé, vous pouvez également la générer en cliquant sur le bouton approprié. Et si vous voulez chiffrer et déchiffrer le texte, tapez-le dans le champ de saisie supérieur.", "Para cifrar archivos o texto, así como descifrarlos, debe ingresar o Leer la clave, también puede generarla haciendo clic en el botón correspondiente. Y si desea cifrar y descifrar el texto, escríbalo en el cuadro de entrada superior."};
    msgBox.setText(yved[yazyk_id]);
    msgBox.exec();
}


void Shif_file_AES(QString key, QString myFile,QString Shif_file){
    // отображаем диалоговое окно

    if(myFile != "" && Shif_file != ""){
        // Получаем текущую директорию
        QString workingDir = QDir::currentPath();

        #ifdef Q_OS_WIN
            QString programPath = workingDir + "/AES_C.exe";
        #elif defined(Q_OS_LINUX)
            QString programPath = workingDir + "/AES_C";
        #elif defined(Q_OS_MAC)
            QString programPath = workingDir + "/AES_C";
        #endif
        // Создаем объект QProcess
        QProcess *process = new QProcess();

        // Устанавливаем рабочую директорию
        process->setWorkingDirectory(workingDir);

        // Указываем аргументы для запускаемой программы
        QStringList arguments;
        arguments << myFile << Shif_file<< key<<"0"; // Здесь добавьте ваши аргументы

        //char* argv[] = {"1",myFile.toUtf8().data(), Shif_file.toUtf8().data(), key.toUtf8().data(), "0"};
        // Запускаем программу с аргументами
        process->start(programPath, arguments);
        //main_AES(5, argv);
        // Проверяем, запустилась ли программа успешно
        /*if (!process->waitForStarted()) {
            qWarning("Не удалось запустить программу!");
            error_file();
        }

        qDebug() << "Программа запущена успешно!";*/
    }
}

void raShif_file_AES(QString key, QString Shif_file,QString raShif_file)
{
    if(raShif_file != "" && Shif_file != ""){
        // Получаем текущую директорию
        QString workingDir = QDir::currentPath();

        // Указываем путь к программе, которую хотим запустить
        #ifdef Q_OS_WIN
        QString programPath = workingDir + "/AES_C.exe";
        #elif defined(Q_OS_LINUX)
        QString programPath = workingDir + "/AES_C";
        #elif defined(Q_OS_MAC)
        QString programPath = workingDir + "/AES_C";
        #endif

        // Создаем объект QProcess
        QProcess *process = new QProcess();

        // Устанавливаем рабочую директорию
        process->setWorkingDirectory(workingDir);

        // Указываем аргументы для запускаемой программы
        QStringList arguments;
        arguments << Shif_file << raShif_file<< key<<"1"; // Здесь добавьте ваши аргументы

        // Запускаем программу с аргументами
        process->start(programPath, arguments);

        // Проверяем, запустилась ли программа успешно
        if (!process->waitForStarted()) {
            qWarning("Не удалось запустить программу!");
            error_file();
        }

        qDebug() << "Программа запущена успешно!";
        //char* argv[] = {"1",Shif_file.toUtf8().data(), raShif_file.toUtf8().data(), key.toUtf8().data(), "1"};
        // Запускаем программу с аргументами
        // process->start(programPath, arguments);
        //main_AES(5, argv);
    }
}
/*QString matrixToQString(const unsigned short matrix[COUNT_BLOCKS_FOR_TEXT][16], int block_count) {
    QByteArray byteArray;
    QDataStream stream(&byteArray, QIODevice::WriteOnly);
    stream.setByteOrder(QDataStream::LittleEndian); // или BigEndian при необходимости

    for (int i = 0; i < block_count; ++i) {
        for (int j = 0; j < 16; ++j) {
            stream << matrix[i][j];
        }
    }

    return QString::fromLatin1(byteArray.toBase64());
}*/

// AES графические функции
void MainWindow::on_pushButton_55_clicked() // шифрование текста
{
    QString isx_text = ui->textEdit_20->toPlainText();
    QString key=ui->lineEdit_5->text();
    if (isx_text != "" && key != ""){
        /*unsigned short matrix_shif[COUNT_BLOCKS_FOR_TEXT][16];
        int block_count;
        Sfif_AES_text(isx_text.toUtf8().data(),matrix_shif, &block_count, key.toUtf8().data());
        ui->textEdit_19->setPlainText(QString::number(block_count)+ " " +matrixToQString(matrix_shif, block_count));*/

        QProcess *process = new QProcess(this);  // Важно: создаём в куче и указываем parent (this)
        QString workingDir = QDir::currentPath();
        // Указываем путь к программе, которую хотим запустить
        #ifdef Q_OS_WIN
                QString programPath = workingDir + "/AES_C.exe";
        #elif defined(Q_OS_LINUX)
                QString programPath = workingDir + "/AES_C";
        #elif defined(Q_OS_MAC)
                QString programPath = workingDir + "/AES_C";
        #endif



        // Соединяем сигналы процесса
        connect(process, &QProcess::readyReadStandardOutput, [process, this]() {
            QString output = process->readAllStandardOutput().trimmed();
            qDebug() << "Получены данные:" << output;
            ui->textEdit_19->setPlainText(output);
            // Можно обновить GUI (например, QLabel->setText(output))
        });

        connect(process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
                [process, this](int exitCode, QProcess::ExitStatus status) {
                    if (status == QProcess::CrashExit) {
                        qDebug() << "Процесс упал!";
                    } else {
                        qDebug() << "Процесс завершён с кодом:" << exitCode;
                    }
                    process->deleteLater();  // Удаляем процесс после завершения
                });
        QStringList arguments;
        arguments << isx_text << key << "-t0"; // Здесь добавьте ваши аргументы
        // Запускаем процесс (путь может быть абсолютным или относительным)
        process->start(programPath, arguments);

        // Передаём данные (если нужно)
        // process->write("Данные для обработки\n");
        process->closeWriteChannel();

    } else{
        AES_error_not_argument(yazyk_id);
    }
}
/*void qstringToMatrix(const QString& str, unsigned short matrix[COUNT_BLOCKS_FOR_TEXT][16], int count) {
    QByteArray byteArray = QByteArray::fromBase64(str.toLatin1());
    QDataStream stream(byteArray);
    stream.setByteOrder(QDataStream::LittleEndian); // должен совпадать с сериализацией

    for (int i = 0; i < count; ++i) {
        for (int j = 0; j < 16; ++j) {
            stream >> matrix[i][j];
        }
    }
}*/
void MainWindow::on_pushButton_48_clicked() // расшифровка текста
{
    QString text_for_rash = ui->textEdit_20->toPlainText();
    QString key=ui->lineEdit_5->text();
    if (text_for_rash != "" && key != ""){
        /*unsigned short matrix_shif[COUNT_BLOCKS_FOR_TEXT][16];
        int space_pos = text_for_rash.indexOf(" ");
        int block_count;
        QString obr_text_for_rash;
        if (space_pos != -1) {
            int block_count = text_for_rash.left(space_pos).toInt();  // "4" -> 4
            QString obr_text_for_rash = text_for_rash.mid(space_pos + 1); // "рандомный текст"
            qstringToMatrix(obr_text_for_rash, matrix_shif, block_count);

            char* rash_text = new char[sizeof(char) * block_count * 16 * 8];//malloc(sizeof(char) * block_count);
            //Sfif_AES_text(isx_text.toUtf8().data(),matrix_shif, &block_count, key.toUtf8().data());
            Rasfif_AES_text(rash_text, matrix_shif, &block_count, key.toUtf8().data());
            ui->textEdit_19->setPlainText(QString::fromUtf8(rash_text) );
            delete[] rash_text;
        }*/

        QProcess *process = new QProcess(this);  // Важно: создаём в куче и указываем parent (this)
        QString workingDir = QDir::currentPath();
        // Указываем путь к программе, которую хотим запустить
        #ifdef Q_OS_WIN
                QString programPath = workingDir + "/AES_C.exe";
        #elif defined(Q_OS_LINUX)
                QString programPath = workingDir + "/AES_C";
        #elif defined(Q_OS_MAC)
                QString programPath = workingDir + "/AES_C";
        #endif



        // Соединяем сигналы процесса
        connect(process, &QProcess::readyReadStandardOutput, [process, this]() {
            QString output = process->readAllStandardOutput().trimmed();
            qDebug() << "Получены данные:" << output;
            ui->textEdit_19->setPlainText(output);
            // Можно обновить GUI (например, QLabel->setText(output))
        });

        connect(process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished),
                [process, this](int exitCode, QProcess::ExitStatus status) {
                    if (status == QProcess::CrashExit) {
                        qDebug() << "Процесс упал!";
                    } else {
                        qDebug() << "Процесс завершён с кодом:" << exitCode;
                    }
                    process->deleteLater();  // Удаляем процесс после завершения
                });
        QStringList arguments;
        arguments << text_for_rash << key << "-t1"; // Здесь добавьте ваши аргументы
        // Запускаем процесс (путь может быть абсолютным или относительным)
        process->start(programPath, arguments);

        // Передаём данные (если нужно)
        // process->write("Данные для обработки\n");
        process->closeWriteChannel();
    }else{
        AES_error_not_argument(yazyk_id);
    }
}


void MainWindow::on_pushButton_5_clicked() // шифрование файла
{
    QString key=ui->lineEdit_5->text(); // QString s;
    if(key != ""){
        QString myFile = QFileDialog::getOpenFileName();
        if(myFile != "" && key != ""){
            QString Shif_file = QFileDialog::getSaveFileName(this, "Сохранить как");
            Shif_file_AES(key, myFile, Shif_file);
        }
    }else{
        AES_error_not_argument(yazyk_id);
    }
}


void MainWindow::on_pushButton_8_clicked() // расшифровка файла
{
    QString key=ui->lineEdit_5->text(); // QString s;
    if(key != ""){
        QString Shif_file = QFileDialog::getOpenFileName();
        if(Shif_file != "" && key != ""){
            QString raShif_file = QFileDialog::getSaveFileName(this, "Сохранить как");
            raShif_file_AES(key, Shif_file, raShif_file);
        }
    }else{
        AES_error_not_argument(yazyk_id);
    }

}


void MainWindow::on_pushButton_6_clicked() // сохранение ключа
{
    QString save_key = QFileDialog::getSaveFileName(this, "Сохранить как");
    QFile file(save_key);
    if (file.open(QIODevice::WriteOnly) && save_key != "")
    {
        QString text = ui->lineEdit_5->text();
        file.write(text.toUtf8()); // Сохраняет
        file.close();
        QMessageBox msgBox;  // диалоговое окно
        msgBox.setIcon(QMessageBox::Information);
        msgBox.setText("Ключ успешно сохранён");  // устанавливаем текст
        msgBox.exec();
    }
    file.close();
}


void MainWindow::on_pushButton_7_clicked() // считание ключа
{
    QString scan_key = QFileDialog::getOpenFileName();
    QFile file(scan_key);
    if(scan_key != ""){
        QByteArray data; // Создаем объект класса QByteArray, куда мы будем считывать данные
        if (!file.open(QIODevice::ReadOnly)) // Проверяем, возможно ли открыть наш файл для чтения
            return; // если это сделать невозможно, то завершаем функцию
        data = file.readAll(); //считываем все данные с файла в объект data
        ui->lineEdit_5->setText(QString(data));  // Выводим данные в lineEdit, предварительно создав строку из полученных данных
        file.close();
    }
}


void MainWindow::on_pushButton_56_clicked() // генерация ключа
{
    QMessageBox msgBox;  // диалоговое окно
    QString save_key = QFileDialog::getSaveFileName(this, "Сохранить как");
    QPoint globalPos = QCursor::pos(); // получаем координаты мыши и переdодим их в текст
    int x = globalPos.x();
    int y = globalPos.y();
    QString xStr = QString::number(x);
    QString yStr = QString::number(y);
    QString  dop_sid = ui->lineEdit_6->text();
    if (dop_sid == "" ) dop_sid = "1232131242342";
    QString argv[] = {"-g", "-s", dop_sid, save_key, xStr, yStr};
    gen_key(4, argv, save_key, read_key_AES);
}
